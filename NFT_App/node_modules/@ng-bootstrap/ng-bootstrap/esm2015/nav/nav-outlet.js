import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Input, ViewChildren, ViewEncapsulation } from '@angular/core';
import { distinctUntilChanged, skip, startWith, takeUntil } from 'rxjs/operators';
import { ngbNavFadeInTransition, ngbNavFadeOutTransition } from './nav-transition';
import { ngbRunTransition } from '../util/transition/ngbTransition';
export class NgbNavPane {
    constructor(elRef) {
        this.elRef = elRef;
    }
}
NgbNavPane.decorators = [
    { type: Directive, args: [{
                selector: '[ngbNavPane]',
                host: {
                    '[id]': 'item.panelDomId',
                    'class': 'tab-pane',
                    '[class.fade]': 'nav.animation',
                    '[attr.role]': 'role ? role : nav.roles ? "tabpanel" : undefined',
                    '[attr.aria-labelledby]': 'item.domId'
                }
            },] }
];
NgbNavPane.ctorParameters = () => [
    { type: ElementRef }
];
NgbNavPane.propDecorators = {
    item: [{ type: Input }],
    nav: [{ type: Input }],
    role: [{ type: Input }]
};
/**
 * The outlet where currently active nav content will be displayed.
 *
 * @since 5.2.0
 */
export class NgbNavOutlet {
    constructor(_cd) {
        this._cd = _cd;
        this._activePane = null;
    }
    isPanelTransitioning(item) { var _a; return ((_a = this._activePane) === null || _a === void 0 ? void 0 : _a.item) === item; }
    ngAfterViewInit() {
        var _a;
        // initial display
        this._updateActivePane();
        // this will be emitted for all 3 types of nav changes: .select(), [activeId] or (click)
        this.nav.navItemChange$
            .pipe(takeUntil(this.nav.destroy$), startWith(((_a = this._activePane) === null || _a === void 0 ? void 0 : _a.item) || null), distinctUntilChanged(), skip(1))
            .subscribe(nextItem => {
            const options = { animation: this.nav.animation, runningTransition: 'stop' };
            // next panel we're switching to will only appear in DOM after the change detection is done
            // and `this._panes` will be updated
            this._cd.detectChanges();
            // fading out
            if (this._activePane) {
                ngbRunTransition(this._activePane.elRef.nativeElement, ngbNavFadeOutTransition, options).subscribe(() => {
                    var _a;
                    const activeItem = (_a = this._activePane) === null || _a === void 0 ? void 0 : _a.item;
                    this._activePane = this._getPaneForItem(nextItem);
                    // mark for check when transition finishes as outlet or parent containers might be OnPush
                    // without this the panes that have "faded out" will stay in DOM
                    this._cd.markForCheck();
                    // fading in
                    if (this._activePane) {
                        // we have to add the '.active' class before running the transition,
                        // because it should be in place before `ngbRunTransition` does `reflow()`
                        this._activePane.elRef.nativeElement.classList.add('active');
                        ngbRunTransition(this._activePane.elRef.nativeElement, ngbNavFadeInTransition, options).subscribe(() => {
                            if (nextItem) {
                                nextItem.shown.emit();
                                this.nav.shown.emit(nextItem.id);
                            }
                        });
                    }
                    if (activeItem) {
                        activeItem.hidden.emit();
                        this.nav.hidden.emit(activeItem.id);
                    }
                });
            }
            else {
                this._updateActivePane();
            }
        });
    }
    _updateActivePane() {
        var _a, _b;
        this._activePane = this._getActivePane();
        (_a = this._activePane) === null || _a === void 0 ? void 0 : _a.elRef.nativeElement.classList.add('show');
        (_b = this._activePane) === null || _b === void 0 ? void 0 : _b.elRef.nativeElement.classList.add('active');
    }
    _getPaneForItem(item) {
        return this._panes && this._panes.find(pane => pane.item === item) || null;
    }
    _getActivePane() {
        return this._panes && this._panes.find(pane => pane.item.active) || null;
    }
}
NgbNavOutlet.decorators = [
    { type: Component, args: [{
                selector: '[ngbNavOutlet]',
                host: { '[class.tab-content]': 'true' },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-template ngFor let-item [ngForOf]="nav.items">
      <div ngbNavPane *ngIf="item.isPanelInDom() || isPanelTransitioning(item)" [item]="item" [nav]="nav" [role]="paneRole">
        <ng-template [ngTemplateOutlet]="item.contentTpl?.templateRef || null"
                     [ngTemplateOutletContext]="{$implicit: item.active || isPanelTransitioning(item)}"></ng-template>
      </div>
    </ng-template>
  `
            },] }
];
NgbNavOutlet.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NgbNavOutlet.propDecorators = {
    _panes: [{ type: ViewChildren, args: [NgbNavPane,] }],
    paneRole: [{ type: Input }],
    nav: [{ type: Input, args: ['ngbNavOutlet',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LW91dGxldC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi9zcmMvIiwic291cmNlcyI6WyJuYXYvbmF2LW91dGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBRUwsWUFBWSxFQUNaLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsb0JBQW9CLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUVoRixPQUFPLEVBQUMsc0JBQXNCLEVBQUUsdUJBQXVCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRixPQUFPLEVBQUMsZ0JBQWdCLEVBQXVCLE1BQU0sa0NBQWtDLENBQUM7QUFheEYsTUFBTSxPQUFPLFVBQVU7SUFLckIsWUFBbUIsS0FBOEI7UUFBOUIsVUFBSyxHQUFMLEtBQUssQ0FBeUI7SUFBRyxDQUFDOzs7WUFmdEQsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxjQUFjO2dCQUN4QixJQUFJLEVBQUU7b0JBQ0osTUFBTSxFQUFFLGlCQUFpQjtvQkFDekIsT0FBTyxFQUFFLFVBQVU7b0JBQ25CLGNBQWMsRUFBRSxlQUFlO29CQUMvQixhQUFhLEVBQUUsa0RBQWtEO29CQUNqRSx3QkFBd0IsRUFBRSxZQUFZO2lCQUN2QzthQUNGOzs7WUFyQkMsVUFBVTs7O21CQXVCVCxLQUFLO2tCQUNMLEtBQUs7bUJBQ0wsS0FBSzs7QUFLUjs7OztHQUlHO0FBZUgsTUFBTSxPQUFPLFlBQVk7SUFldkIsWUFBb0IsR0FBc0I7UUFBdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFkbEMsZ0JBQVcsR0FBc0IsSUFBSSxDQUFDO0lBY0QsQ0FBQztJQUU5QyxvQkFBb0IsQ0FBQyxJQUFnQixZQUFJLE9BQU8sT0FBQSxJQUFJLENBQUMsV0FBVywwQ0FB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QUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDN0UsQ0FBQztJQUVPLGNBQWM7UUFDcEIsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDM0UsQ0FBQzs7O1lBN0ZGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixJQUFJLEVBQUUsRUFBQyxxQkFBcUIsRUFBRSxNQUFNLEVBQUM7Z0JBQ3JDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsUUFBUSxFQUFFOzs7Ozs7O0dBT1Q7YUFDRjs7O1lBbkRDLGlCQUFpQjs7O3FCQXVEaEIsWUFBWSxTQUFDLFVBQVU7dUJBS3ZCLEtBQUs7a0JBS0wsS0FBSyxTQUFDLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgUXVlcnlMaXN0LFxuICBWaWV3Q2hpbGRyZW4sXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc2tpcCwgc3RhcnRXaXRoLCB0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtuZ2JOYXZGYWRlSW5UcmFuc2l0aW9uLCBuZ2JOYXZGYWRlT3V0VHJhbnNpdGlvbn0gZnJvbSAnLi9uYXYtdHJhbnNpdGlvbic7XG5pbXBvcnQge25nYlJ1blRyYW5zaXRpb24sIE5nYlRyYW5zaXRpb25PcHRpb25zfSBmcm9tICcuLi91dGlsL3RyYW5zaXRpb24vbmdiVHJhbnNpdGlvbic7XG5pbXBvcnQge05nYk5hdiwgTmdiTmF2SXRlbX0gZnJvbSAnLi9uYXYnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmdiTmF2UGFuZV0nLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAnaXRlbS5wYW5lbERvbUlkJyxcbiAgICAnY2xhc3MnOiAndGFiLXBhbmUnLFxuICAgICdbY2xhc3MuZmFkZV0nOiAnbmF2LmFuaW1hdGlvbicsXG4gICAgJ1thdHRyLnJvbGVdJzogJ3JvbGUgPyByb2xlIDogbmF2LnJvbGVzID8gXCJ0YWJwYW5lbFwiIDogdW5kZWZpbmVkJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdpdGVtLmRvbUlkJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE5nYk5hdlBhbmUge1xuICBASW5wdXQoKSBpdGVtOiBOZ2JOYXZJdGVtO1xuICBASW5wdXQoKSBuYXY6IE5nYk5hdjtcbiAgQElucHV0KCkgcm9sZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4pIHt9XG59XG5cbi8qKlxuICogVGhlIG91dGxldCB3aGVyZSBjdXJyZW50bHkgYWN0aXZlIG5hdiBjb250ZW50IHdpbGwgYmUgZGlzcGxheWVkLlxuICpcbiAqIEBzaW5jZSA1LjIuMFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbbmdiTmF2T3V0bGV0XScsXG4gIGhvc3Q6IHsnW2NsYXNzLnRhYi1jb250ZW50XSc6ICd0cnVlJ30sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJuYXYuaXRlbXNcIj5cbiAgICAgIDxkaXYgbmdiTmF2UGFuZSAqbmdJZj1cIml0ZW0uaXNQYW5lbEluRG9tKCkgfHwgaXNQYW5lbFRyYW5zaXRpb25pbmcoaXRlbSlcIiBbaXRlbV09XCJpdGVtXCIgW25hdl09XCJuYXZcIiBbcm9sZV09XCJwYW5lUm9sZVwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiaXRlbS5jb250ZW50VHBsPy50ZW1wbGF0ZVJlZiB8fCBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpdGVtLmFjdGl2ZSB8fCBpc1BhbmVsVHJhbnNpdGlvbmluZyhpdGVtKX1cIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBOZ2JOYXZPdXRsZXQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgcHJpdmF0ZSBfYWN0aXZlUGFuZTogTmdiTmF2UGFuZSB8IG51bGwgPSBudWxsO1xuXG4gIEBWaWV3Q2hpbGRyZW4oTmdiTmF2UGFuZSkgcHJpdmF0ZSBfcGFuZXM6IFF1ZXJ5TGlzdDxOZ2JOYXZQYW5lPjtcblxuICAvKipcbiAgICogQSByb2xlIHRvIHNldCBvbiB0aGUgbmF2IHBhbmVcbiAgICovXG4gIEBJbnB1dCgpIHBhbmVSb2xlO1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGBOZ2JOYXZgXG4gICAqL1xuICBASW5wdXQoJ25nYk5hdk91dGxldCcpIG5hdjogTmdiTmF2O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICBpc1BhbmVsVHJhbnNpdGlvbmluZyhpdGVtOiBOZ2JOYXZJdGVtKSB7IHJldHVybiB0aGlzLl9hY3RpdmVQYW5lID8uaXRlbSA9PT0gaXRlbTsgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBpbml0aWFsIGRpc3BsYXlcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVQYW5lKCk7XG5cbiAgICAvLyB0aGlzIHdpbGwgYmUgZW1pdHRlZCBmb3IgYWxsIDMgdHlwZXMgb2YgbmF2IGNoYW5nZXM6IC5zZWxlY3QoKSwgW2FjdGl2ZUlkXSBvciAoY2xpY2spXG4gICAgdGhpcy5uYXYubmF2SXRlbUNoYW5nZSRcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm5hdi5kZXN0cm95JCksIHN0YXJ0V2l0aCh0aGlzLl9hY3RpdmVQYW5lID8uaXRlbSB8fCBudWxsKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc2tpcCgxKSlcbiAgICAgIC5zdWJzY3JpYmUobmV4dEl0ZW0gPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogTmdiVHJhbnNpdGlvbk9wdGlvbnM8dW5kZWZpbmVkPiA9IHthbmltYXRpb246IHRoaXMubmF2LmFuaW1hdGlvbiwgcnVubmluZ1RyYW5zaXRpb246ICdzdG9wJ307XG5cbiAgICAgIC8vIG5leHQgcGFuZWwgd2UncmUgc3dpdGNoaW5nIHRvIHdpbGwgb25seSBhcHBlYXIgaW4gRE9NIGFmdGVyIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIGRvbmVcbiAgICAgIC8vIGFuZCBgdGhpcy5fcGFuZXNgIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAvLyBmYWRpbmcgb3V0XG4gICAgICBpZiAodGhpcy5fYWN0aXZlUGFuZSkge1xuICAgICAgICBuZ2JSdW5UcmFuc2l0aW9uKHRoaXMuX2FjdGl2ZVBhbmUuZWxSZWYubmF0aXZlRWxlbWVudCwgbmdiTmF2RmFkZU91dFRyYW5zaXRpb24sIG9wdGlvbnMpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IHRoaXMuX2FjdGl2ZVBhbmUgPy5pdGVtO1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZVBhbmUgPSB0aGlzLl9nZXRQYW5lRm9ySXRlbShuZXh0SXRlbSk7XG5cbiAgICAgICAgICAvLyBtYXJrIGZvciBjaGVjayB3aGVuIHRyYW5zaXRpb24gZmluaXNoZXMgYXMgb3V0bGV0IG9yIHBhcmVudCBjb250YWluZXJzIG1pZ2h0IGJlIE9uUHVzaFxuICAgICAgICAgIC8vIHdpdGhvdXQgdGhpcyB0aGUgcGFuZXMgdGhhdCBoYXZlIFwiZmFkZWQgb3V0XCIgd2lsbCBzdGF5IGluIERPTVxuICAgICAgICAgIHRoaXMuX2NkLm1hcmtGb3JDaGVjaygpO1xuXG4gICAgICAgICAgLy8gZmFkaW5nIGluXG4gICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVBhbmUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gYWRkIHRoZSAnLmFjdGl2ZScgY2xhc3MgYmVmb3JlIHJ1bm5pbmcgdGhlIHRyYW5zaXRpb24sXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IHNob3VsZCBiZSBpbiBwbGFjZSBiZWZvcmUgYG5nYlJ1blRyYW5zaXRpb25gIGRvZXMgYHJlZmxvdygpYFxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGFuZS5lbFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgbmdiUnVuVHJhbnNpdGlvbih0aGlzLl9hY3RpdmVQYW5lLmVsUmVmLm5hdGl2ZUVsZW1lbnQsIG5nYk5hdkZhZGVJblRyYW5zaXRpb24sIG9wdGlvbnMpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0SXRlbSkge1xuICAgICAgICAgICAgICAgIG5leHRJdGVtLnNob3duLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdi5zaG93bi5lbWl0KG5leHRJdGVtLmlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW0uaGlkZGVuLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMubmF2LmhpZGRlbi5lbWl0KGFjdGl2ZUl0ZW0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVQYW5lKCk7XG4gICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZUFjdGl2ZVBhbmUoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGFuZSA9IHRoaXMuX2dldEFjdGl2ZVBhbmUoKTtcbiAgICB0aGlzLl9hY3RpdmVQYW5lID8uZWxSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgdGhpcy5fYWN0aXZlUGFuZSA/LmVsUmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRQYW5lRm9ySXRlbShpdGVtOiBOZ2JOYXZJdGVtIHwgbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9wYW5lcyAmJiB0aGlzLl9wYW5lcy5maW5kKHBhbmUgPT4gcGFuZS5pdGVtID09PSBpdGVtKSB8fCBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0QWN0aXZlUGFuZSgpOiBOZ2JOYXZQYW5lIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3BhbmVzICYmIHRoaXMuX3BhbmVzLmZpbmQocGFuZSA9PiBwYW5lLml0ZW0uYWN0aXZlKSB8fCBudWxsO1xuICB9XG59XG4iXX0=