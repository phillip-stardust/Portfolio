import { EMPTY, fromEvent, of, race, Subject, timer } from 'rxjs';
import { endWith, filter, takeUntil } from 'rxjs/operators';
import { getTransitionDurationMs } from './util';
import { environment } from '../../environment';
import { reflow } from '../util';
const noopFn = () => { };
const ɵ0 = noopFn;
const { transitionTimerDelayMs } = environment;
const runningTransitions = new Map();
export const ngbRunTransition = (element, startFn, options) => {
    // Getting initial context from options
    let context = options.context || {};
    // Checking if there are already running transitions on the given element.
    const running = runningTransitions.get(element);
    if (running) {
        switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
                return EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.
            case 'stop':
                running.transition$.complete();
                context = Object.assign(running.context, context);
                runningTransitions.delete(element);
        }
    }
    // A reflow is required here, to be sure that everything is ready,
    // Without reflow, the transition will not be started for some widgets, at initialization time
    reflow(element);
    const endFn = startFn(element, context) || noopFn;
    // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
    // If animations are disabled, we have to emit a value and complete the observable
    // In this case we have to call the end function, but can finish immediately by emitting a value,
    // completing the observable and executing end functions synchronously.
    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        endFn();
        return of(undefined);
    }
    // Starting a new transition
    const transition$ = new Subject();
    const finishTransition$ = new Subject();
    const stop$ = transition$.pipe(endWith(true));
    runningTransitions.set(element, {
        transition$,
        complete: () => {
            finishTransition$.next();
            finishTransition$.complete();
        },
        context
    });
    const transitionDurationMs = getTransitionDurationMs(element);
    // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
    // because 'transitionend' event might not be fired in some browsers, if the transitioning
    // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
    // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
    // 2. We need to filter transition end events, because they might bubble from shorter transitions
    // on inner DOM elements. We're only interested in the transition on the 'element' itself.
    const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({ target }) => target === element));
    const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));
    race(timer$, transitionEnd$, finishTransition$).pipe(takeUntil(stop$)).subscribe(() => {
        runningTransitions.delete(element);
        endFn();
        transition$.next();
        transition$.complete();
    });
    return transition$.asObservable();
};
export const ngbCompleteTransition = (element) => {
    var _a;
    (_a = runningTransitions.get(element)) === null || _a === void 0 ? void 0 : _a.complete();
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdiVHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi9zcmMvIiwic291cmNlcyI6WyJ1dGlsL3RyYW5zaXRpb24vbmdiVHJhbnNpdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUQsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQy9DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBaUIvQixNQUFNLE1BQU0sR0FBdUIsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDOztBQUU1QyxNQUFNLEVBQUMsc0JBQXNCLEVBQUMsR0FBRyxXQUFXLENBQUM7QUFDN0MsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBc0MsQ0FBQztBQUV6RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FDekIsQ0FBSSxPQUFvQixFQUFFLE9BQWdDLEVBQUUsT0FBZ0MsRUFDbEUsRUFBRTtJQUV0Qix1Q0FBdUM7SUFDdkMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBTyxFQUFFLENBQUM7SUFFdkMsMEVBQTBFO0lBQzFFLE1BQU0sT0FBTyxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoRCxJQUFJLE9BQU8sRUFBRTtRQUNYLFFBQVEsT0FBTyxDQUFDLGlCQUFpQixFQUFFO1lBQ2pDLGtHQUFrRztZQUNsRywrRUFBK0U7WUFDL0UsS0FBSyxVQUFVO2dCQUNiLE9BQU8sS0FBSyxDQUFDO1lBQ2YsNkZBQTZGO1lBQzdGLHlHQUF5RztZQUN6Ryx5REFBeUQ7WUFDekQsS0FBSyxNQUFNO2dCQUNULE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQy9CLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ2xELGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN0QztLQUNGO0lBRUQsa0VBQWtFO0lBQ2xFLDhGQUE4RjtJQUM5RixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFaEIsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUM7SUFFbEQsaUZBQWlGO0lBQ2pGLGtGQUFrRjtJQUNsRixpR0FBaUc7SUFDakcsdUVBQXVFO0lBQ3ZFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxrQkFBa0IsS0FBSyxNQUFNLEVBQUU7UUFDeEYsS0FBSyxFQUFFLENBQUM7UUFDUixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN0QjtJQUVELDRCQUE0QjtJQUM1QixNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO0lBQ3ZDLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztJQUM3QyxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUU7UUFDOUIsV0FBVztRQUNYLFFBQVEsRUFBRSxHQUFHLEVBQUU7WUFDYixpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN6QixpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMvQixDQUFDO1FBQ0QsT0FBTztLQUNSLENBQUMsQ0FBQztJQUVILE1BQU0sb0JBQW9CLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFOUQsMkZBQTJGO0lBQzNGLDBGQUEwRjtJQUMxRiwrRkFBK0Y7SUFDL0Ysa0ZBQWtGO0lBQ2xGLGlHQUFpRztJQUNqRywwRkFBMEY7SUFDMUYsTUFBTSxjQUFjLEdBQ2hCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN6RyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsb0JBQW9CLEdBQUcsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFFM0YsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNwRixrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUM7UUFDUixXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbkIsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDcEMsQ0FBQyxDQUFDO0FBRVYsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxPQUFvQixFQUFFLEVBQUU7O0lBQzVELE1BQUEsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQywwQ0FBRyxRQUFRLEdBQUc7QUFDL0MsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFTVBUWSwgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBvZiwgcmFjZSwgU3ViamVjdCwgdGltZXJ9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtlbmRXaXRoLCBmaWx0ZXIsIHRha2VVbnRpbH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtnZXRUcmFuc2l0aW9uRHVyYXRpb25Nc30gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7ZW52aXJvbm1lbnR9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7cmVmbG93fSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IHR5cGUgTmdiVHJhbnNpdGlvblN0YXJ0Rm48VCA9IGFueT4gPSAoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbnRleHQ6IFQpID0+IE5nYlRyYW5zaXRpb25FbmRGbiB8IHZvaWQ7XG5leHBvcnQgdHlwZSBOZ2JUcmFuc2l0aW9uRW5kRm4gPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5nYlRyYW5zaXRpb25PcHRpb25zPFQ+IHtcbiAgYW5pbWF0aW9uOiBib29sZWFuO1xuICBydW5uaW5nVHJhbnNpdGlvbjogJ2NvbnRpbnVlJyB8ICdzdG9wJztcbiAgY29udGV4dD86IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmdiVHJhbnNpdGlvbkN0eDxUPiB7XG4gIHRyYW5zaXRpb24kOiBTdWJqZWN0PGFueT47XG4gIGNvbXBsZXRlOiAoKSA9PiB2b2lkO1xuICBjb250ZXh0OiBUO1xufVxuXG5jb25zdCBub29wRm46IE5nYlRyYW5zaXRpb25FbmRGbiA9ICgpID0+IHt9O1xuXG5jb25zdCB7dHJhbnNpdGlvblRpbWVyRGVsYXlNc30gPSBlbnZpcm9ubWVudDtcbmNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9ucyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIE5nYlRyYW5zaXRpb25DdHg8YW55Pj4oKTtcblxuZXhwb3J0IGNvbnN0IG5nYlJ1blRyYW5zaXRpb24gPVxuICAgIDxUPihlbGVtZW50OiBIVE1MRWxlbWVudCwgc3RhcnRGbjogTmdiVHJhbnNpdGlvblN0YXJ0Rm48VD4sIG9wdGlvbnM6IE5nYlRyYW5zaXRpb25PcHRpb25zPFQ+KTpcbiAgICAgICAgT2JzZXJ2YWJsZTx1bmRlZmluZWQ+ID0+IHtcblxuICAgICAgICAgIC8vIEdldHRpbmcgaW5pdGlhbCBjb250ZXh0IGZyb20gb3B0aW9uc1xuICAgICAgICAgIGxldCBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IDxUPnt9O1xuXG4gICAgICAgICAgLy8gQ2hlY2tpbmcgaWYgdGhlcmUgYXJlIGFscmVhZHkgcnVubmluZyB0cmFuc2l0aW9ucyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ1RyYW5zaXRpb25zLmdldChlbGVtZW50KTtcbiAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLnJ1bm5pbmdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9uZSBydW5uaW5nIGFuZCB3ZSB3YW50IGZvciBpdCB0byAnY29udGludWUnIHRvIHJ1biwgd2UgaGF2ZSB0byBjYW5jZWwgdGhlIG5ldyBvbmUuXG4gICAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBlbWl0dGluZyBhbnkgdmFsdWVzLCBidXQgc2ltcGx5IGNvbXBsZXRpbmcgdGhlIG9ic2VydmFibGUgKEVNUFRZKS5cbiAgICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25lIHJ1bm5pbmcgYW5kIHdlIHdhbnQgZm9yIGl0IHRvICdzdG9wJywgd2UgaGF2ZSB0byBjb21wbGV0ZSB0aGUgcnVubmluZyBvbmUuXG4gICAgICAgICAgICAgIC8vIFdlJ3JlIHNpbXBseSBjb21wbGV0aW5nIHRoZSBydW5uaW5nIG9uZSBhbmQgbm90IGVtaXR0aW5nIGFueSB2YWx1ZXMgYW5kIG1lcmdpbmcgbmV3bHkgcHJvdmlkZWQgY29udGV4dFxuICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBvbmUgY29taW5nIGZyb20gY3VycmVudGx5IHJ1bm5pbmcgdHJhbnNpdGlvbi5cbiAgICAgICAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgICAgICAgcnVubmluZy50cmFuc2l0aW9uJC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuYXNzaWduKHJ1bm5pbmcuY29udGV4dCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcnVubmluZ1RyYW5zaXRpb25zLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIHJlZmxvdyBpcyByZXF1aXJlZCBoZXJlLCB0byBiZSBzdXJlIHRoYXQgZXZlcnl0aGluZyBpcyByZWFkeSxcbiAgICAgICAgICAvLyBXaXRob3V0IHJlZmxvdywgdGhlIHRyYW5zaXRpb24gd2lsbCBub3QgYmUgc3RhcnRlZCBmb3Igc29tZSB3aWRnZXRzLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lXG4gICAgICAgICAgcmVmbG93KGVsZW1lbnQpO1xuXG4gICAgICAgICAgY29uc3QgZW5kRm4gPSBzdGFydEZuKGVsZW1lbnQsIGNvbnRleHQpIHx8IG5vb3BGbjtcblxuICAgICAgICAgIC8vIElmICdwcmVmZXItcmVkdWNlZC1tb3Rpb24nIGlzIGVuYWJsZWQsIHRoZSAndHJhbnNpdGlvbicgd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgICAgICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBoYXZlIHRvIGVtaXQgYSB2YWx1ZSBhbmQgY29tcGxldGUgdGhlIG9ic2VydmFibGVcbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBjYWxsIHRoZSBlbmQgZnVuY3Rpb24sIGJ1dCBjYW4gZmluaXNoIGltbWVkaWF0ZWx5IGJ5IGVtaXR0aW5nIGEgdmFsdWUsXG4gICAgICAgICAgLy8gY29tcGxldGluZyB0aGUgb2JzZXJ2YWJsZSBhbmQgZXhlY3V0aW5nIGVuZCBmdW5jdGlvbnMgc3luY2hyb25vdXNseS5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnRyYW5zaXRpb25Qcm9wZXJ0eSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBlbmRGbigpO1xuICAgICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnRpbmcgYSBuZXcgdHJhbnNpdGlvblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgICAgICAgIGNvbnN0IGZpbmlzaFRyYW5zaXRpb24kID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgICAgICAgIGNvbnN0IHN0b3AkID0gdHJhbnNpdGlvbiQucGlwZShlbmRXaXRoKHRydWUpKTtcbiAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuc2V0KGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24kLFxuICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgZmluaXNoVHJhbnNpdGlvbiQubmV4dCgpO1xuICAgICAgICAgICAgICBmaW5pc2hUcmFuc2l0aW9uJC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbk1zID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uTXMoZWxlbWVudCk7XG5cbiAgICAgICAgICAvLyAxLiBXZSBoYXZlIHRvIGJvdGggbGlzdGVuIGZvciB0aGUgJ3RyYW5zaXRpb25lbmQnIGV2ZW50IGFuZCBoYXZlIGEgJ2p1c3QtaW4tY2FzZScgdGltZXIsXG4gICAgICAgICAgLy8gYmVjYXVzZSAndHJhbnNpdGlvbmVuZCcgZXZlbnQgbWlnaHQgbm90IGJlIGZpcmVkIGluIHNvbWUgYnJvd3NlcnMsIGlmIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAgICAgICAgLy8gZWxlbWVudCBiZWNvbWVzIGludmlzaWJsZSAoZXguIHdoZW4gc2Nyb2xsaW5nLCBtYWtpbmcgYnJvd3NlciB0YWIgaW5hY3RpdmUsIGV0Yy4pLiBUaGUgdGltZXJcbiAgICAgICAgICAvLyBndWFyYW50ZWVzLCB0aGF0IHdlJ2xsIHJlbGVhc2UgdGhlIERPTSBlbGVtZW50IGFuZCBjb21wbGV0ZSAnbmdiUnVuVHJhbnNpdGlvbicuXG4gICAgICAgICAgLy8gMi4gV2UgbmVlZCB0byBmaWx0ZXIgdHJhbnNpdGlvbiBlbmQgZXZlbnRzLCBiZWNhdXNlIHRoZXkgbWlnaHQgYnViYmxlIGZyb20gc2hvcnRlciB0cmFuc2l0aW9uc1xuICAgICAgICAgIC8vIG9uIGlubmVyIERPTSBlbGVtZW50cy4gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIG9uIHRoZSAnZWxlbWVudCcgaXRzZWxmLlxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25FbmQkID1cbiAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJykucGlwZSh0YWtlVW50aWwoc3RvcCQpLCBmaWx0ZXIoKHt0YXJnZXR9KSA9PiB0YXJnZXQgPT09IGVsZW1lbnQpKTtcbiAgICAgICAgICBjb25zdCB0aW1lciQgPSB0aW1lcih0cmFuc2l0aW9uRHVyYXRpb25NcyArIHRyYW5zaXRpb25UaW1lckRlbGF5TXMpLnBpcGUodGFrZVVudGlsKHN0b3AkKSk7XG5cbiAgICAgICAgICByYWNlKHRpbWVyJCwgdHJhbnNpdGlvbkVuZCQsIGZpbmlzaFRyYW5zaXRpb24kKS5waXBlKHRha2VVbnRpbChzdG9wJCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgZW5kRm4oKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24kLm5leHQoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24kLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbiQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH07XG5cbmV4cG9ydCBjb25zdCBuZ2JDb21wbGV0ZVRyYW5zaXRpb24gPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcbiAgcnVubmluZ1RyYW5zaXRpb25zLmdldChlbGVtZW50KSA/LmNvbXBsZXRlKCk7XG59O1xuIl19